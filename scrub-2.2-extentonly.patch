diff -up scrub-2.2/man/scrub.1.in.extentonly scrub-2.2/man/scrub.1.in
--- scrub-2.2/man/scrub.1.in.extentonly	2012-10-08 16:12:09.299493224 +0200
+++ scrub-2.2/man/scrub.1.in	2012-10-08 16:20:23.694392280 +0200
@@ -110,6 +110,13 @@ or
 .I "G"
 may be appended to the number to change the units to
 KiBytes, MiBytes, or GiBytes, respectively.
+.TP
+\fI-E\fR, \fI--extent-only\fR
+When scrubbing regular files, scrub only the file extents. This option is
+useful in combination with large sparse files. If used, scrub will skip
+the holes in the sparse file. Use this option with caution, the result may not
+be compliant with cited standards and information about the actual on-disk
+data allocation may leak since only the allocated parts will be scrubbed.
 .SH CAVEATS
 .B Scrub 
 may be insufficient to thwart heroic efforts to recover data 
diff -up scrub-2.2/src/fextent_apply.c.extentonly scrub-2.2/src/fextent_apply.c
--- scrub-2.2/src/fextent_apply.c.extentonly	2012-10-08 16:11:25.260414695 +0200
+++ scrub-2.2/src/fextent_apply.c	2012-10-08 16:07:04.220955199 +0200
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2012 Red Hat Inc., Durham, North Carolina.
+ * All Rights Reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software 
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Authors:
+ *      Daniel Kopecek <dkopecek@redhat.com>
+ */
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/file.h>
+
+#include <linux/fs.h>
+#include <linux/fiemap.h>
+
+#ifndef NDEBUG
+# define dP(...)				\
+    do { int  __tmp_errno = errno;		\
+	fprintf(stderr, "DEBUG: "__VA_ARGS__);	\
+	errno = __tmp_errno;			\
+    } while(0)
+#else
+# define dP(...) while(0)
+#endif
+
+int fextent_apply(int fd, int (*function)(int, struct fiemap_extent *, void *), void *arg)
+{
+    int ret = -1;
+    struct stat st;
+    struct fiemap *em;
+    uint32_t extent_count, i;
+
+    // lock, sync, stat
+    if (flock(fd, LOCK_EX) != 0) {
+	dP("flock(%d, LOCK_EX) failed: %s, %d.\n", fd, strerror(errno), errno);
+	return -1;
+    }
+    if (fsync(fd) != 0) {
+	dP("fsync(%d) failed: %s, %d.\n", fd, strerror(errno), errno);
+	goto exit_1;
+    }
+    if (fstat(fd, &st) != 0) {
+	dP("fstat(%d) failed: %s, %d.\n", fd, strerror(errno), errno);
+	goto exit_1;
+    }
+    
+    /*
+     * fiemap => get extent count
+     */
+    em = malloc(sizeof(struct fiemap));
+
+    if (em == NULL) {
+	dP("malloc(%zu) returned NULL!\n", sizeof(struct fiemap));
+	goto exit_1;
+    }
+
+    memset(em, 0, sizeof(struct fiemap));
+
+    em->fm_start = 0;
+    em->fm_length = st.st_size;
+    em->fm_extent_count = 0;
+    em->fm_mapped_extents = 0;
+    em->fm_flags = 0;
+
+    if (ioctl(fd, FS_IOC_FIEMAP, em) != 0) {
+	dP("FS_IOC_FIEMAP: %s, %d.\n", strerror(errno), errno);
+	goto exit_0;
+    }
+
+    extent_count = em->fm_mapped_extents;
+    free(em);
+
+    /*
+     * fiemap => get extents
+     */
+    em = malloc (sizeof(struct fiemap)
+		 + (sizeof(struct fiemap_extent) * extent_count));
+
+    if (em == NULL) {
+	dP("malloc(%zu) returned NULL!\n", sizeof(struct fiemap)
+	   + (sizeof (struct fiemap_extent) * extent_count));
+	goto exit_0;
+    }
+
+    memset(em, 0, sizeof(struct fiemap)
+	   + (sizeof(struct fiemap_extent) * extent_count));
+
+    em[0].fm_start = 0;
+    em[0].fm_length = st.st_size;
+    em[0].fm_extent_count = extent_count;
+    em[0].fm_flags = 0;
+
+    if (ioctl(fd, FS_IOC_FIEMAP, em) != 0) {
+	dP("FS_IOC_FIEMAP: %s, %d.\n", strerror(errno), errno);
+	goto exit_0;
+    }
+   
+    for (i = 0; i < extent_count; ++i) {
+	// seek to extent start
+	if (lseek(fd, em->fm_extents[i].fe_logical, SEEK_SET) == (off_t)-1) {
+	    dP("lseek(%d, %llu, SET) failed: %s, %d.\n",
+	       fd, em->fm_extents[i].fe_logical, strerror(errno), errno);
+	    goto exit_0;
+	}
+
+	ret = function(fd, em->fm_extents + i, arg);
+	if (ret != 0)
+	    goto exit_0;
+    }
+
+    ret = 0;
+  exit_0:
+    // release resources
+    free (em);
+  exit_1:
+    // unlock
+    if (flock(fd, LOCK_UN) != 0)
+	ret = -1;
+
+    return ret;
+}
diff -up scrub-2.2/src/fextent_apply.h.extentonly scrub-2.2/src/fextent_apply.h
--- scrub-2.2/src/fextent_apply.h.extentonly	2012-10-08 16:11:27.403418520 +0200
+++ scrub-2.2/src/fextent_apply.h	2012-10-08 16:07:04.220955199 +0200
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2012 Red Hat Inc., Durham, North Carolina.
+ * All Rights Reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software 
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Authors:
+ *      Daniel Kopecek <dkopecek@redhat.com>
+ */
+#ifndef FEXTENT_APPLY_H
+#define FEXTENT_APPLY_H
+
+#include <linux/fs.h>
+#include <linux/fiemap.h>
+
+int fextent_apply(int fd, int (*function)(int, struct fiemap_extent *, void *), void *arg);
+
+#endif /* FEXTENT_APPLY_H */
\ No newline at end of file
diff -up scrub-2.2/src/fillfile.c.extentonly scrub-2.2/src/fillfile.c
--- scrub-2.2/src/fillfile.c.extentonly	2012-10-08 16:09:27.644206371 +0200
+++ scrub-2.2/src/fillfile.c	2012-10-08 16:07:04.220955199 +0200
@@ -38,9 +38,24 @@
 
 #include "util.h"
 #include "fillfile.h"
+#include "fextent_apply.h"
 
 extern char *prog;
 
+struct fillfile_args {
+    char *path;
+    off_t filesize;
+    unsigned char *mem;
+    int memsize;
+    progress_t progress;
+    void *arg;
+    refill_t refill;
+    unsigned char *buf;
+};
+
+int fillextent(int fd, struct fiemap_extent *extent, void *pa);
+int checkextent(int fd, struct fiemap_extent *extent, void *pa);
+
 /* Fill file (can be regular or special file) with pattern in mem.
  * Writes will use memsize blocks.
  * If 'refill' is non-null, call it before each write (for random fill).
@@ -48,11 +63,12 @@ extern char *prog;
  * If 'sparse' is true, only scrub first and last blocks (for testing).
  * The number of bytes written is returned.
  * If 'creat' is true, open with O_CREAT and allow ENOSPC to be non-fatal.
+ * IF 'extentonly' is true, fill only file extents with the given pattern
  */
 off_t
 fillfile(char *path, off_t filesize, unsigned char *mem, int memsize,
          progress_t progress, void *arg, refill_t refill, 
-         bool sparse, bool creat)
+         bool sparse, bool creat, bool extentonly)
 {
     int fd;
     off_t n;
@@ -68,32 +84,49 @@ fillfile(char *path, off_t filesize, uns
         fprintf(stderr, "%s: open %s: %s\n", prog, path, strerror(errno));
         exit(1);
     }
-    do {
-        if (refill && !sparse)
-            refill(mem, memsize);
-        if (written + memsize > filesize)
-            memsize = filesize - written;
-        if (sparse && !(written == 0) && !(written + memsize == filesize)) {
-            if (lseek(fd, memsize, SEEK_CUR) < 0) {
-                fprintf(stderr, "%s: lseek %s: %s\n", prog, path, 
-                        strerror(errno));
-                exit(1);
-            }
-            written += memsize;
-        } else {
-            n = write_all(fd, mem, memsize);
-            if (creat && n < 0 && errno == ENOSPC)
-                break;
-            if (n < 0) {
-                fprintf(stderr, "%s: write %s: %s\n", prog, path, 
-                        strerror(errno));
-                exit(1);
-            }
-            written += n;
-        }
-        if (progress)
-            progress(arg, (double)written/filesize);
-    } while (written < filesize);
+    
+    if (extentonly) {
+	struct fillfile_args fa;
+	
+	fa.path = path;
+	fa.filesize = filesize;
+	fa.mem = mem;
+	fa.memsize = memsize;
+	fa.progress = progress;
+	fa.refill = refill;
+	fa.arg = arg;
+	
+	if (fextent_apply(fd, fillextent, &fa) == 0)
+	  written = filesize;
+    } else {
+        do {
+            if (refill && !sparse)
+                refill(mem, memsize);
+            if (written + memsize > filesize)
+                memsize = filesize - written;
+            if (sparse && !(written == 0) && !(written + memsize == filesize)) {
+                if (lseek(fd, memsize, SEEK_CUR) < 0) {
+                    fprintf(stderr, "%s: lseek %s: %s\n", prog, path,
+                            strerror(errno));
+                    exit(1);
+                }
+                written += memsize;
+            } else {
+                n = write_all(fd, mem, memsize);
+                if (creat && n < 0 && errno == ENOSPC)
+                    break;
+                if (n < 0) {
+                    fprintf(stderr, "%s: write %s: %s\n", prog, path,
+                            strerror(errno));
+                    exit(1);
+                }
+                written += n;
+            }
+            if (progress)
+                progress(arg, (double)written/filesize);
+        } while (written < filesize);
+    }
+    
     if (close(fd) < 0) {
         fprintf(stderr, "%s: close %s: %s\n", prog, path, strerror(errno));
         exit(1);
@@ -105,60 +138,137 @@ fillfile(char *path, off_t filesize, uns
  */
 off_t
 checkfile(char *path, off_t filesize, unsigned char *mem, int memsize,
-          progress_t progress, void *arg, bool sparse)
+          progress_t progress, void *arg, bool sparse, bool extentonly)
 {
     int fd;
     off_t n;
     off_t verified = 0LL;
     unsigned char *buf;
 
-    buf = malloc(memsize);
-    if (!buf) {
-        fprintf(stderr, "out of memory\n");
-        exit(1);
-    }
     fd = open(path, O_RDONLY);
     if (fd < 0) {
         fprintf(stderr, "%s: open %s: %s\n", prog, path, strerror(errno));
         exit(1);
     }
-    do {
-        if (verified + memsize > filesize)
-            memsize = filesize - verified;
-        if (sparse && !(verified == 0) && !(verified + memsize == filesize)) {
-            if (lseek(fd, memsize, SEEK_CUR) < 0) {
-                fprintf(stderr, "%s: lseek %s: %s\n", prog, path, 
-                        strerror(errno));
-                exit(1);
-            }
-            verified += memsize;
-        } else {
-            n = read_all(fd, buf, memsize);
-            if (n < 0) {
-                fprintf(stderr, "%s: read %s: %s", prog, path, strerror(errno));
-                exit(1);
-            }
-            if (n == 0) {
-                fprintf(stderr, "%s: premature EOF on %s\n", prog, path);
-                exit(1);
-            }
-            if (memcmp(mem, buf, memsize) != 0) {
-                fprintf(stderr, "%s: verification failure on %s\n", prog, path);
-                exit(1);
-            }
-            verified += n;
+    if (extentonly) {
+        struct fillfile_args fa;
+
+        fa.path = path;
+        fa.filesize = filesize;
+        fa.mem = mem;
+        fa.memsize = memsize;
+        fa.progress = progress;
+        fa.arg = arg;
+        fa.buf = malloc(memsize);
+
+        if (fextent_apply(fd, checkextent, &fa) == 0)
+            verified = filesize;
+
+        free(fa.buf);
+    } else {
+        buf = malloc(memsize);
+        if (!buf) {
+            fprintf(stderr, "out of memory\n");
+            exit(1);
         }
-        if (progress)
-            progress(arg, (double)verified/filesize);
-    } while (verified < filesize);
+        do {
+            if (verified + memsize > filesize)
+                memsize = filesize - verified;
+            if (sparse && !(verified == 0) && !(verified + memsize == filesize)) {
+                if (lseek(fd, memsize, SEEK_CUR) < 0) {
+                    fprintf(stderr, "%s: lseek %s: %s\n", prog, path,
+                            strerror(errno));
+                    exit(1);
+                }
+                verified += memsize;
+            } else {
+                n = read_all(fd, buf, memsize);
+                if (n < 0) {
+                    fprintf(stderr, "%s: read %s: %s", prog, path, strerror(errno));
+                    exit(1);
+                }
+                if (n == 0) {
+                    fprintf(stderr, "%s: premature EOF on %s\n", prog, path);
+                    exit(1);
+                }
+                if (memcmp(mem, buf, memsize) != 0) {
+                    fprintf(stderr, "%s: verification failure on %s\n", prog, path);
+                    exit(1);
+                }
+                verified += n;
+            }
+            if (progress)
+                progress(arg, (double)verified/filesize);
+        } while (verified < filesize);
+        free(buf);
+    }
     if (close(fd) < 0) {
         fprintf(stderr, "%s: close %s: %s\n", prog, path, strerror(errno));
         exit(1);
     }
-    free(buf);
+
     return verified;
 }
 
+int fillextent(int fd, struct fiemap_extent *extent, void *pa)
+{
+    off_t n;
+    off_t written = 0LL;
+    struct fillfile_args args = *(struct fillfile_args *)(pa);
+    
+    do {
+        if (args.refill)
+            args.refill(args.mem, args.memsize);
+
+        if (written + args.memsize > extent->fe_length)
+            args.memsize = extent->fe_length - written;
+
+        n = write_all(fd, args.mem, args.memsize);
+
+        if (n < 0) {
+            fprintf(stderr, "%s: write %s: %s\n", prog, args.path, strerror(errno));
+            exit(1);
+        }
+        written += n;
+
+        if (args.progress)
+            args.progress(args.arg, (double)(extent->fe_logical + written)/args.filesize);
+    } while (written < extent->fe_length);
+
+    return 0;
+}
+
+int checkextent(int fd, struct fiemap_extent *extent, void *pa)
+{
+    off_t n;
+    off_t verified = 0LL;
+    struct fillfile_args args = *(struct fillfile_args *)(pa);
+
+    do {
+        if (verified + args.memsize > extent->fe_length)
+            args.memsize = extent->fe_length - verified;
+
+        n = read_all(fd, args.buf, args.memsize);
+        if (n < 0) {
+            fprintf(stderr, "%s: read %s: %s", prog, args.path, strerror(errno));
+            exit(1);
+        }
+        if (n == 0) {
+            fprintf(stderr, "%s: premature EOF on %s\n", prog, args.path);
+            exit(1);
+        }
+        if (memcmp(args.mem, args.buf, args.memsize) != 0) {
+            fprintf(stderr, "%s: verification failure on %s\n", prog, args.path);
+            exit(1);
+        }
+        verified += n;
+        if (args.progress)
+            args.progress(args.arg, (double)(extent->fe_logical+verified)/args.filesize);
+    } while (verified < extent->fe_length);
+
+    return 0;
+}
+
 /*
  * vi:tabstop=4 shiftwidth=4 expandtab
  */
diff -up scrub-2.2/src/fillfile.h.extentonly scrub-2.2/src/fillfile.h
--- scrub-2.2/src/fillfile.h.extentonly	2012-10-08 16:10:59.876369554 +0200
+++ scrub-2.2/src/fillfile.h	2012-10-08 16:07:04.221955201 +0200
@@ -29,6 +29,6 @@ typedef void (*refill_t) (unsigned char
 
 off_t fillfile(char *path, off_t filesize, unsigned char *mem, int memsize,
         progress_t progress, void *arg, refill_t refill, 
-        bool sparse, bool creat);
+        bool sparse, bool creat, bool extentonly);
 off_t checkfile(char *path, off_t filesize, unsigned char *mem, int memsize,
-        progress_t progress, void *arg, bool sparse);
+        progress_t progress, void *arg, bool sparse, bool extentonly);
diff -up scrub-2.2/src/Makefile.am.extentonly scrub-2.2/src/Makefile.am
--- scrub-2.2/src/Makefile.am.extentonly	2012-10-08 16:09:50.086245960 +0200
+++ scrub-2.2/src/Makefile.am	2012-10-08 16:07:04.216955191 +0200
@@ -3,5 +3,6 @@ bin_PROGRAMS = scrub
 scrub_SOURCES = \
 	aes.c filldentry.c fillfile.c genrand.c \
 	getsize.c pattern.c progress.c scrub.c sig.c util.c \
+	fextent_apply.c fextent_apply.h \
 	aes.h filldentry.h fillfile.h genrand.h getsize.h \
 	pattern.h progress.h sig.h util.h
diff -up scrub-2.2/src/scrub.c.extentonly scrub-2.2/src/scrub.c
--- scrub-2.2/src/scrub.c.extentonly	2012-10-08 16:09:15.389184783 +0200
+++ scrub-2.2/src/scrub.c	2012-10-08 16:07:04.216955191 +0200
@@ -63,12 +63,12 @@
 
 static void       usage(void);
 static bool       scrub(char *path, off_t size, const sequence_t *seq,
-                      int bufsize, bool Sopt, bool sparse, bool enospc);
+                      int bufsize, bool Sopt, bool sparse, bool enospc, bool extentonly);
 static void       scrub_free(char *path, off_t size, const sequence_t *seq,
                       int bufsize, bool Sopt);
 static void       scrub_dirent(char *path, char *newpath);
 static void       scrub_file(char *path, off_t size, const sequence_t *seq,
-                      int bufsize, bool Sopt, bool sparse);
+                      int bufsize, bool Sopt, bool sparse, bool extentonly);
 #if __APPLE__
 static void       scrub_resfork(char *path, const sequence_t *seq,
                       int bufsize);
@@ -76,7 +76,7 @@ static void       scrub_resfork(char *pa
 static void       scrub_disk(char *path, off_t size, const sequence_t *seq,
                       int bufsize, bool Sopt, bool sparse);
 
-#define OPTIONS "p:D:Xb:s:fSrvT"
+#define OPTIONS "p:D:Xb:s:fSrvTE"
 #if HAVE_GETOPT_LONG
 #define GETOPT(ac,av,opt,lopt) getopt_long(ac,av,opt,lopt,NULL)
 static struct option longopts[] = {
@@ -90,6 +90,7 @@ static struct option longopts[] = {
     {"remove",           no_argument,        0, 'r'},
     {"version",          no_argument,        0, 'v'},
     {"test-sparse",      no_argument,        0, 'T'},
+    {"extent-only",      no_argument,        0, 'E'},
     {0, 0, 0, 0},
 };
 #else
@@ -111,6 +112,7 @@ main(int argc, char *argv[])
     bool Sopt = false;
     bool ropt = false;
     bool Topt = false;
+    bool Eopt = false;
     extern int optind;
     extern char *optarg;
     int c;
@@ -164,6 +166,9 @@ main(int argc, char *argv[])
         case 'T':   /* --test-sparse */
             Topt = true;
             break;
+	case 'E':   /* --extent-only */
+	    Eopt = true;
+	    break;
         default:
             usage();
         }
@@ -235,7 +240,7 @@ main(int argc, char *argv[])
                         prog, Dopt, filename);
                 exit(1);
             }
-            scrub_file(filename, sopt, seq, bopt, Sopt, Topt);
+            scrub_file(filename, sopt, seq, bopt, Sopt, Topt, Eopt);
 #if __APPLE__
             scrub_resfork(filename, seq, bopt);
 #endif
@@ -259,7 +264,7 @@ main(int argc, char *argv[])
 static void 
 usage(void)
 {
-    fprintf(stderr, "Usage: %s [OPTIONS] file\n%s%s%s%s%s%s%s%s%s", prog,
+    fprintf(stderr, "Usage: %s [OPTIONS] file\n%s%s%s%s%s%s%s%s%s%s", prog,
 "  -v, --version           display scrub version and exit\n",
 "  -p, --pattern pat       select scrub pattern sequence\n",
 "  -b, --blocksize size    set I/O buffer size (default 1m)\n",
@@ -268,7 +273,8 @@ usage(void)
 "  -D, --dirent newname    after scrubbing file, scrub dir entry, rename\n",
 "  -f, --force             scrub despite signature from previous scrub\n",
 "  -S, --no-signature      do not write scrub signature after scrub\n",
-"  -r, --remove            remove file after scrub\n");
+"  -r, --remove            remove file after scrub\n",
+"  -E, --extent-only       scrub only file extents\n");
     exit(1);
 }
 
@@ -279,7 +285,7 @@ usage(void)
  */
 static bool
 scrub(char *path, off_t size, const sequence_t *seq, int bufsize, 
-      bool Sopt, bool sparse, bool enospc)
+      bool Sopt, bool sparse, bool enospc, bool extentonly)
 {
     unsigned char *buf;
     int i;
@@ -307,7 +313,7 @@ scrub(char *path, off_t size, const sequ
                 churnrand();
                 written = fillfile(path, size, buf, bufsize, 
                                    (progress_t)progress_update, p, 
-                                   (refill_t)genrand, sparse, enospc);
+                                   (refill_t)genrand, sparse, enospc, extentonly);
                 progress_destroy(p);
                 break;
             case NORMAL:
@@ -316,7 +322,7 @@ scrub(char *path, off_t size, const sequ
                 memset_pat(buf, seq->pat[i], bufsize);
                 written = fillfile(path, size, buf, bufsize, 
                                    (progress_t)progress_update, p, 
-                                   NULL, sparse, enospc);
+                                   NULL, sparse, enospc, extentonly);
                 progress_destroy(p);
                 break;
             case VERIFY:
@@ -325,12 +331,12 @@ scrub(char *path, off_t size, const sequ
                 memset_pat(buf, seq->pat[i], bufsize);
                 written = fillfile(path, size, buf, bufsize, 
                                    (progress_t)progress_update, p, 
-                                   NULL, sparse, enospc);
+                                   NULL, sparse, enospc, extentonly);
                 progress_destroy(p);
                 printf("%s: %-8s", prog, "verify");
                 progress_create(&p, 50);
                 checkfile(path, written, buf, bufsize, 
-                          (progress_t)progress_update, p, sparse);
+                          (progress_t)progress_update, p, sparse, extentonly);
                 progress_destroy(p);
                 break;
         }
@@ -405,7 +411,7 @@ scrub_free(char *dirpath, off_t size, co
 
     do {
         snprintf(path, sizeof(path), "%s/scrub.%.3d", dirpath, fileno++);
-        isfull = scrub(path, size, seq, bufsize, Sopt, false, true);
+        isfull = scrub(path, size, seq, bufsize, Sopt, false, true, false);
     } while (!isfull);
 }
 
@@ -443,7 +449,7 @@ scrub_dirent(char *path, char *newpath)
  */
 static void 
 scrub_file(char *path, off_t size, const sequence_t *seq, 
-           int bufsize, bool Sopt, bool sparse)
+           int bufsize, bool Sopt, bool sparse, bool extentonly)
 {
     struct stat sb;
     filetype_t ftype = filetype(path);
@@ -468,7 +474,7 @@ scrub_file(char *path, off_t size, const
                     prog, path, (int)(size - sb.st_size)); 
         }
     }
-    scrub(path, size, seq, bufsize, Sopt, sparse, false);
+    scrub(path, size, seq, bufsize, Sopt, sparse, false, extentonly);
 }
 
 /* Scrub apple resource fork component of file.
@@ -496,7 +502,7 @@ scrub_resfork(char *path, const sequence
         printf("%s: padding %s with %d bytes to fill last fs block\n", 
                         prog, rpath, (int)(rsize - rsb.st_size)); 
     }
-    scrub(rpath, rsize, seq, bufsize, false, false, false);
+    scrub(rpath, rsize, seq, bufsize, false, false, false, false);
 }
 #endif
 
@@ -517,7 +523,7 @@ scrub_disk(char *path, off_t size, const
         }
         printf("%s: please verify that device size below is correct!\n", prog);
     }
-    scrub(path, size, seq, bufsize, Sopt, sparse, false);
+    scrub(path, size, seq, bufsize, Sopt, sparse, false, false);
 }
 
 /*
